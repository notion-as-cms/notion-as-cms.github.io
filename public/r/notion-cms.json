{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "notion-cms",
  "title": "Notion Content CMS",
  "description": "A flexible content system powered by Notion. Supports multiple content sources (blog, changelog, updates, etc.) with pagination, tag filtering, syntax highlighting, and full-featured content rendering. Built with Next.js App Router and React Server Components.",
  "dependencies": [
    "@notionhq/client@3.1.1",
    "notion-compat@7.3.0",
    "notion-utils@7.3.0",
    "notion-types@7.3.0",
    "react-notion-x@7.3.0",
    "lucide-react@0.511.0",
    "prismjs@1.30.0",
    "@types/prismjs@1.26.5"
  ],
  "registryDependencies": [
    "button",
    "sheet",
    "scroll-area"
  ],
  "files": [
    {
      "path": "components/notion/content-page.tsx",
      "content": "import { Renderer } from \"./renderer\";\nimport { MobileTOC, DesktopTOC, type TOCConfig } from \"./table-of-contents\";\nimport Image from \"next/image\";\nimport Link from \"next/link\";\nimport type { Tag, TOCEntry } from \"@/components/notion/types\";\nimport type { ExtendedRecordMap } from \"notion-types\";\nimport { Calendar } from \"lucide-react\";\n\ninterface PageInfo {\n  date?: string;\n  toc?: TOCEntry[];\n  [key: string]: any;\n}\n\ninterface ContentPageProps {\n  recordMap: ExtendedRecordMap & {\n    pageInfo: PageInfo;\n  };\n  basePath?: string;\n  /** TOC configuration for header offset and mobile positioning */\n  tocConfig?: TOCConfig;\n}\n\nexport function ContentPage({ recordMap, basePath = \"/blog\", tocConfig }: ContentPageProps) {\n  const { tags = [], cover, title, description, toc = [] } = recordMap.pageInfo || {};\n  const safeTags = (tags as Tag[]) || [];\n\n  // Get the last edited time from the first block\n  const lastEditedTime =\n    recordMap.block[Object.keys(recordMap.block)[0]]?.value?.last_edited_time;\n\n  const hasTOC = toc.length > 0;\n\n  return (\n    <article>\n      {/* Header Section */}\n      <header className=\"py-8 lg:py-12\">\n        {/* Cover Image */}\n        {cover && (\n          <div className=\"relative w-full h-64 md:h-96 mb-8 rounded-lg overflow-hidden\">\n            <Image\n              src={cover}\n              alt=\"Cover image\"\n              fill\n              className=\"object-cover\"\n              priority\n              unoptimized\n            />\n          </div>\n        )}\n\n        {/* Date */}\n        {lastEditedTime && (\n          <div className=\"mb-4 text-muted-foreground text-sm font-medium\">\n            <span className=\"inline-flex items-center gap-1.5\">\n              <Calendar className=\"h-4 w-4\" />\n              {new Date(lastEditedTime).toLocaleDateString(\"en-US\", {\n                year: \"numeric\",\n                month: \"long\",\n                day: \"numeric\",\n              })}\n            </span>\n          </div>\n        )}\n\n        {/* Title */}\n        <h1 className=\"text-3xl md:text-4xl lg:text-5xl font-bold tracking-tight text-foreground\">\n          {title || \"Untitled\"}\n        </h1>\n\n        {/* Description */}\n        {description && (\n          <p className=\"mt-4 text-lg text-muted-foreground\">\n            {description}\n          </p>\n        )}\n\n        {/* Tags */}\n        {safeTags.length > 0 && (\n          <div className=\"flex flex-wrap gap-2 mt-6\">\n            {safeTags.map((tag) => (\n              <Link\n                key={tag.id}\n                href={`${basePath}/tag/${tag.value}`}\n                className=\"px-3 py-1 bg-secondary hover:bg-secondary/80 text-secondary-foreground rounded-full text-sm font-medium transition-colors\"\n              >\n                {tag.label}\n              </Link>\n            ))}\n          </div>\n        )}\n      </header>\n\n      {/* Content Section with TOC */}\n      <div className=\"py-8 lg:py-12\">\n          {/* Mobile TOC - shown at top on mobile */}\n          {hasTOC && <MobileTOC toc={toc} config={tocConfig} />}\n\n          <div className={hasTOC ? \"lg:flex lg:gap-10\" : \"\"}>\n            {/* Desktop TOC - left sidebar */}\n            {hasTOC && (\n              <aside className=\"hidden lg:block lg:w-56 lg:shrink-0\">\n                <DesktopTOC toc={toc} config={tocConfig} />\n              </aside>\n            )}\n\n            {/* Main Content */}\n            <div className={hasTOC ? \"lg:flex-1 lg:min-w-0\" : \"\"}>\n              <div\n                className=\"prose prose-neutral dark:prose-invert max-w-none\n                  prose-headings:font-semibold prose-headings:text-foreground\n                  prose-headings:scroll-mt-24\n                  prose-h1:text-3xl prose-h2:text-2xl prose-h3:text-xl\n                  prose-p:text-muted-foreground\n                  prose-a:text-primary hover:prose-a:text-primary/80\n                  prose-strong:text-foreground\n                  prose-code:text-sm prose-code:bg-muted prose-code:text-foreground\n                  prose-pre:bg-card prose-pre:border prose-pre:border-border\n                  prose-img:rounded-lg\n                  prose-blockquote:border-l-primary prose-blockquote:text-muted-foreground\"\n                style={{ \"--notion-max-width\": \"100%\" } as React.CSSProperties}\n              >\n                <Renderer\n                  recordMap={recordMap}\n                  fullPage={false}\n                  darkMode={false}\n                  showTableOfContents={false}\n                />\n              </div>\n            </div>\n          </div>\n      </div>\n    </article>\n  );\n}\n\n// Alias for backward compatibility\nexport { ContentPage as BlogPost };\n",
      "type": "registry:component",
      "target": "components/notion/content-page.tsx"
    },
    {
      "path": "components/notion/content-list.tsx",
      "content": "import { ItemList } from \"./item-list\";\nimport { mapNotionPostToBlogPost } from \"@/lib/notion/notion-mappers\";\nimport type { ContentItem, ContentListProps } from \"@/components/notion/types\";\nimport { DEFAULT_POSTS_PER_PAGE } from \"@/lib/notion/config\";\n\nexport function ContentList({\n  posts,\n  tags,\n  authors = [],\n  pageParams,\n  isPaginated = false,\n  heading = \"Latest Posts\",\n  basePath = \"/blog\",\n  configuration,\n}: ContentListProps) {\n  const currentPage = isPaginated ? getPageNumber(pageParams) : 1;\n  const postsPerPage = configuration?.pageSize ?? DEFAULT_POSTS_PER_PAGE;\n\n  // Map all posts, filtering out any null or invalid posts\n  // Pass basePath and authors to mapper so URLs and author names are resolved correctly\n  const allBlogPosts = posts\n    .map((post) => mapNotionPostToBlogPost(post, tags, basePath, authors))\n    .filter((post): post is ContentItem => post !== null);\n\n  // Calculate total pages based on all valid posts\n  const totalPages = Math.ceil(allBlogPosts.length / postsPerPage);\n\n  // Apply pagination if enabled, otherwise show all posts\n  const displayedPosts = isPaginated\n    ? allBlogPosts.slice(\n        (currentPage - 1) * postsPerPage,\n        currentPage * postsPerPage\n      )\n    : allBlogPosts;\n\n  return (\n    <ItemList\n      posts={displayedPosts}\n      currentPage={currentPage}\n      totalPages={totalPages}\n      heading={heading}\n      basePath={basePath}\n      disablePagination={!isPaginated}\n    />\n  );\n}\n\n// Alias for backward compatibility\nexport { ContentList as BlogList };\n\n// Helper function to get page number from params\nfunction getPageNumber(pageParams: { slug?: string[] }): number {\n  if (!pageParams.slug || pageParams.slug.length === 0) return 1;\n  const page = parseInt(pageParams.slug[pageParams.slug.length - 1], 10);\n  return isNaN(page) ? 1 : Math.max(1, page);\n}\n",
      "type": "registry:component",
      "target": "components/notion/content-list.tsx"
    },
    {
      "path": "components/notion/item-list.tsx",
      "content": "import { ArrowRight } from \"lucide-react\";\nimport Link from \"next/link\";\nimport { Pagination } from \"./pagination\";\nimport type { ContentItem, ItemListProps } from \"@/components/notion/types\";\n\nexport function ItemList({\n  posts,\n  currentPage,\n  totalPages,\n  heading = \"Latest\",\n  description,\n  basePath = \"/blog\",\n  disablePagination = false,\n  configuration = {},\n}: ItemListProps) {\n  return (\n    <div className=\"py-8 lg:py-12\">\n      <section className=\"mb-12 text-center\">\n        <h1 className=\"text-4xl font-bold mb-4\">{heading}</h1>\n        {description && (\n          <p className=\"text-lg text-muted-foreground\">{description}</p>\n        )}\n      </section>\n\n      <section className=\"space-y-12\">\n        {posts.map((post) =>\n          post ? <ItemCard key={post.id} item={post} /> : null\n        )}\n      </section>\n\n      {!disablePagination && totalPages > 1 && (\n        <div className=\"mt-12 flex justify-center\">\n          <Pagination\n            currentPage={currentPage}\n            totalPages={totalPages}\n            basePath={basePath || \"/blog\"}\n          />\n        </div>\n      )}\n    </div>\n  );\n}\n\n// Alias for backward compatibility\nexport { ItemList as PostList };\n\nfunction ItemCard({ item }: { item: ContentItem }) {\n  const { title, description, author, date, tags = [], cover } = item.data;\n\n  return (\n    <article className=\"group\">\n      <div className=\"grid gap-y-6 sm:grid-cols-10 sm:gap-x-5 sm:gap-y-0 md:items-center md:gap-x-8 lg:gap-x-12\">\n        <div className=\"sm:col-span-5\">\n          <div className=\"mb-4 md:mb-6\">\n            <div className=\"flex flex-wrap gap-3 text-xs uppercase tracking-wider text-muted-foreground md:gap-5 lg:gap-6\">\n              {tags.map((tag) => (\n                <span key={tag}>{tag}</span>\n              ))}\n            </div>\n          </div>\n          <h3 className=\"text-xl font-semibold md:text-2xl lg:text-3xl text-left\">\n            <Link href={item.url} className=\"hover:underline cursor-pointer\">\n              {title}\n            </Link>\n          </h3>\n          <p className=\"mt-4 text-muted-foreground md:mt-5 text-left\">\n            {description}\n          </p>\n          <div className=\"mt-6 flex items-center space-x-4 text-sm md:mt-8\">\n            <span className=\"text-muted-foreground capitalize\">\n              {author || \"Anonymous\"}\n            </span>\n            <span className=\"text-muted-foreground\">‚Ä¢</span>\n            <span className=\"text-muted-foreground\">\n              {new Date(date).toDateString()}\n            </span>\n          </div>\n          <div className=\"mt-6 flex items-center space-x-2 md:mt-8\">\n            <Link\n              href={item.url}\n              className=\"inline-flex items-center font-semibold hover:underline md:text-base\"\n            >\n              <span>Read more</span>\n              <ArrowRight className=\"ml-2 size-4 transition-transform\" />\n            </Link>\n          </div>\n        </div>\n        <div className=\"order-first sm:order-last sm:col-span-5\">\n          <Link href={item.url} className=\"block\">\n            <div className=\"aspect-[16/9] overflow-clip rounded-lg border border-border bg-muted\">\n              {cover ? (\n                <img\n                  src={cover}\n                  alt={title}\n                  className=\"h-full w-full object-cover transition-opacity duration-200 hover:opacity-70\"\n                />\n              ) : (\n                <div className=\"h-full w-full flex items-center justify-center text-muted-foreground\">\n                  <span className=\"text-4xl\">üìù</span>\n                </div>\n              )}\n            </div>\n          </Link>\n        </div>\n      </div>\n    </article>\n  );\n}\n",
      "type": "registry:component",
      "target": "components/notion/item-list.tsx"
    },
    {
      "path": "components/notion/pagination.tsx",
      "content": "import Link from \"next/link\";\nimport { ChevronLeft, ChevronRight } from \"lucide-react\";\nimport { Button } from \"@/components/ui/button\";\nimport type { PaginationProps } from \"@/components/notion/types\";\n\nexport function Pagination({\n  currentPage,\n  totalPages,\n  basePath = \"/blog\",\n}: PaginationProps) {\n  // Ensure currentPage is within valid range\n  const safeCurrentPage = Math.max(1, Math.min(currentPage, totalPages));\n  const pageIndex = safeCurrentPage - 1;\n\n  // Don't render if there's only one page or no pages\n  if (totalPages <= 1) {\n    return null;\n  }\n\n  // Generate proper href for the previous page\n  const getPreviousHref = () => {\n    if (pageIndex <= 1) return basePath;\n    return `${basePath}/page/${pageIndex}`;\n  };\n\n  // Generate proper href for the next page\n  const getNextHref = () => {\n    return `${basePath}/page/${safeCurrentPage + 1}`;\n  };\n\n  return (\n    <nav \n      className=\"flex justify-center mt-8 space-x-4\" \n      aria-label=\"Pagination\"\n    >\n      <div className=\"flex items-center gap-4\">\n        {/* Previous Page Button */}\n        <Button\n          variant=\"outline\"\n          size=\"sm\"\n          asChild={pageIndex > 0}\n          disabled={pageIndex === 0}\n          aria-disabled={pageIndex === 0 ? \"true\" : undefined}\n          className=\"min-w-[7rem]\"\n        >\n          {pageIndex > 0 ? (\n            <Link\n              href={getPreviousHref()}\n              prefetch={false}\n              className=\"flex items-center justify-center\"\n              aria-label=\"Previous page\"\n            >\n              <ChevronLeft className=\"h-4 w-4 mr-1\" />\n              Previous\n            </Link>\n          ) : (\n            <span className=\"flex items-center\">\n              <ChevronLeft className=\"h-4 w-4 mr-1\" />\n              Previous\n            </span>\n          )}\n        </Button>\n\n        {/* Page Indicator */}\n        <div \n          className=\"text-sm text-muted-foreground px-4 py-2 bg-muted rounded-md\"\n          aria-current=\"page\"\n        >\n          Page {safeCurrentPage} of {totalPages}\n        </div>\n\n        {/* Next Page Button */}\n        <Button\n          variant=\"outline\"\n          size=\"sm\"\n          asChild={pageIndex + 1 < totalPages}\n          disabled={pageIndex + 1 >= totalPages}\n          aria-disabled={pageIndex + 1 >= totalPages ? \"true\" : undefined}\n          className=\"min-w-[7rem]\"\n        >\n          {pageIndex + 1 < totalPages ? (\n            <Link \n              href={getNextHref()} \n              prefetch={false}\n              className=\"flex items-center justify-center\"\n              aria-label=\"Next page\"\n            >\n              Next\n              <ChevronRight className=\"h-4 w-4 ml-1\" />\n            </Link>\n          ) : (\n            <span className=\"flex items-center\">\n              Next\n              <ChevronRight className=\"h-4 w-4 ml-1\" />\n            </span>\n          )}\n        </Button>\n      </div>\n    </nav>\n  );\n}\n",
      "type": "registry:component",
      "target": "components/notion/pagination.tsx"
    },
    {
      "path": "components/notion/renderer.tsx",
      "content": "\"use client\";\nimport { NotionRenderer } from \"react-notion-x\";\nimport { useState, useEffect, type ComponentProps } from \"react\";\nimport Link from \"next/link\";\nimport dynamic from \"next/dynamic\";\nimport { useTheme } from \"next-themes\";\n\nconst Code = dynamic(() =>\n  import(\"react-notion-x/build/third-party/code\").then(async (m) => {\n    // additional prism syntaxes\n    await Promise.all([\n      import(\"prismjs/components/prism-markup-templating.js\"),\n      import(\"prismjs/components/prism-markup.js\"),\n      import(\"prismjs/components/prism-bash.js\"),\n      import(\"prismjs/components/prism-c.js\"),\n      import(\"prismjs/components/prism-cpp.js\"),\n      import(\"prismjs/components/prism-csharp.js\"),\n      import(\"prismjs/components/prism-docker.js\"),\n      import(\"prismjs/components/prism-java.js\"),\n      import(\"prismjs/components/prism-js-templates.js\"),\n      import(\"prismjs/components/prism-coffeescript.js\"),\n      import(\"prismjs/components/prism-diff.js\"),\n      import(\"prismjs/components/prism-git.js\"),\n      import(\"prismjs/components/prism-go.js\"),\n      import(\"prismjs/components/prism-graphql.js\"),\n      import(\"prismjs/components/prism-handlebars.js\"),\n      import(\"prismjs/components/prism-less.js\"),\n      import(\"prismjs/components/prism-makefile.js\"),\n      import(\"prismjs/components/prism-markdown.js\"),\n      import(\"prismjs/components/prism-objectivec.js\"),\n      import(\"prismjs/components/prism-ocaml.js\"),\n      import(\"prismjs/components/prism-python.js\"),\n      import(\"prismjs/components/prism-reason.js\"),\n      import(\"prismjs/components/prism-rust.js\"),\n      import(\"prismjs/components/prism-sass.js\"),\n      import(\"prismjs/components/prism-scss.js\"),\n      import(\"prismjs/components/prism-solidity.js\"),\n      import(\"prismjs/components/prism-sql.js\"),\n      import(\"prismjs/components/prism-stylus.js\"),\n      import(\"prismjs/components/prism-swift.js\"),\n      import(\"prismjs/components/prism-wasm.js\"),\n      import(\"prismjs/components/prism-yaml.js\"),\n    ]);\n    return m.Code;\n  })\n);\n\nexport function Renderer(props: ComponentProps<typeof NotionRenderer>) {\n  const { resolvedTheme } = useTheme();\n  const [mounted, setMounted] = useState(false);\n\n  useEffect(() => {\n    setMounted(true);\n  }, []);\n\n  return (\n    <NotionRenderer\n      {...props}\n      darkMode={mounted && resolvedTheme === \"dark\"}\n      components={{\n        nextLink: Link,\n        Code,\n      }}\n      previewImages={false}\n    />\n  );\n}\n",
      "type": "registry:component",
      "target": "components/notion/renderer.tsx"
    },
    {
      "path": "components/notion/table-of-contents.tsx",
      "content": "\"use client\";\n\nimport { useEffect, useState, useRef, useLayoutEffect, useCallback } from \"react\";\nimport { cn } from \"@/lib/utils\";\nimport { List } from \"lucide-react\";\nimport { Button } from \"@/components/ui/button\";\nimport {\n  Sheet,\n  SheetContent,\n  SheetHeader,\n  SheetTitle,\n  SheetTrigger,\n} from \"@/components/ui/sheet\";\nimport { ScrollArea } from \"@/components/ui/scroll-area\";\nimport type {\n  TOCEntry,\n  TOCConfig,\n} from \"@/components/notion/types\";\n\n// Re-export for convenience\nexport type { TOCConfig };\n\n// Default offset for scroll calculations (accounts for sticky headers)\nconst DEFAULT_HEADER_OFFSET = 100;\n\ninterface TableOfContentsProps {\n  toc: TOCEntry[];\n  config?: TOCConfig;\n  className?: string;\n}\n\n/** Convert hyphenated UUID to non-hyphenated (notion-utils vs react-notion-x format) */\nconst toElementId = (id: string) => id.replace(/-/g, \"\");\n\n/** Convert element ID back to hyphenated format for TOC matching */\nconst toTocId = (elementId: string) => {\n  // Convert 32-char hex to UUID format: 8-4-4-4-12\n  if (elementId.length === 32 && /^[a-f0-9]+$/.test(elementId)) {\n    return `${elementId.slice(0, 8)}-${elementId.slice(8, 12)}-${elementId.slice(12, 16)}-${elementId.slice(16, 20)}-${elementId.slice(20)}`;\n  }\n  return elementId;\n};\n\n/**\n * Hook for scroll spy with URL sync\n * - Tracks which heading is currently at the top of viewport\n * - Syncs with URL hash on load and hash changes\n * - Updates URL when scrolling\n */\nfunction useActiveAnchor(toc: TOCEntry[], headerOffset: number) {\n  const [activeId, setActiveId] = useState<string | null>(null);\n  const isScrollingRef = useRef(false);\n  const scrollTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n\n  // Get active ID from URL hash on mount\n  useEffect(() => {\n    if (toc.length === 0) return;\n\n    const hash = window.location.hash.slice(1); // Remove #\n    if (hash) {\n      const tocId = toTocId(hash);\n      const matchingItem = toc.find(\n        (item) => item.id === tocId || toElementId(item.id) === hash\n      );\n      if (matchingItem) {\n        setActiveId(matchingItem.id);\n        return;\n      }\n    }\n    // Default to first item\n    setActiveId(toc[0].id);\n  }, [toc]);\n\n  // Listen for hash changes (e.g., browser back/forward)\n  useEffect(() => {\n    const handleHashChange = () => {\n      const hash = window.location.hash.slice(1);\n      if (hash) {\n        const tocId = toTocId(hash);\n        const matchingItem = toc.find(\n          (item) => item.id === tocId || toElementId(item.id) === hash\n        );\n        if (matchingItem) {\n          setActiveId(matchingItem.id);\n        }\n      }\n    };\n\n    window.addEventListener(\"hashchange\", handleHashChange);\n    return () => window.removeEventListener(\"hashchange\", handleHashChange);\n  }, [toc]);\n\n  // Scroll spy - update active heading based on scroll position\n  useEffect(() => {\n    if (toc.length === 0) return;\n\n    const ids = toc.map((item) => item.id);\n\n    const updateActiveHeading = () => {\n      // Don't update during programmatic scrolling\n      if (isScrollingRef.current) return;\n\n      // Find the heading that's closest to the header offset line\n      // We want the heading that's just at or slightly above the offset\n      let bestMatch: string | null = null;\n      let bestDistance = Infinity;\n\n      for (const id of ids) {\n        const element = document.getElementById(toElementId(id));\n        if (!element) continue;\n\n        const rect = element.getBoundingClientRect();\n        const distanceFromOffset = rect.top - headerOffset;\n\n        // Heading is at or above the offset line\n        if (distanceFromOffset <= 0) {\n          // We want the one closest to 0 (just past the line)\n          const absDistance = Math.abs(distanceFromOffset);\n          if (absDistance < bestDistance) {\n            bestDistance = absDistance;\n            bestMatch = id;\n          }\n        }\n      }\n\n      // If no heading is above offset, use the first visible one or first overall\n      if (!bestMatch) {\n        for (const id of ids) {\n          const element = document.getElementById(toElementId(id));\n          if (!element) continue;\n          const rect = element.getBoundingClientRect();\n          if (rect.top >= 0 && rect.top < window.innerHeight) {\n            bestMatch = id;\n            break;\n          }\n        }\n      }\n\n      if (!bestMatch && ids.length > 0) {\n        bestMatch = ids[0];\n      }\n\n      if (bestMatch && bestMatch !== activeId) {\n        setActiveId(bestMatch);\n        // Only update visual highlight, don't update URL hash on scroll\n        // URL hash should only change when user explicitly clicks a link\n      }\n    };\n\n    updateActiveHeading();\n    window.addEventListener(\"scroll\", updateActiveHeading, { passive: true });\n    return () => window.removeEventListener(\"scroll\", updateActiveHeading);\n  }, [toc, headerOffset, activeId]);\n\n  // Function to set active ID and mark as scrolling (to prevent scroll spy override)\n  const setActiveWithScroll = useCallback((id: string) => {\n    isScrollingRef.current = true;\n    setActiveId(id);\n\n    // Clear any existing timeout\n    if (scrollTimeoutRef.current) {\n      clearTimeout(scrollTimeoutRef.current);\n    }\n\n    // Re-enable scroll spy after scrolling completes\n    scrollTimeoutRef.current = setTimeout(() => {\n      isScrollingRef.current = false;\n    }, 1000); // Wait for smooth scroll to complete\n  }, []);\n\n  // Cleanup timeout on unmount\n  useEffect(() => {\n    return () => {\n      if (scrollTimeoutRef.current) {\n        clearTimeout(scrollTimeoutRef.current);\n      }\n    };\n  }, []);\n\n  return { activeId, setActiveWithScroll };\n}\n\n/** Individual TOC item with auto-scroll when becoming active */\nfunction TOCItem({\n  item,\n  isActive,\n  containerRef,\n  headerOffset,\n  onItemClick,\n}: {\n  item: TOCEntry;\n  isActive: boolean;\n  containerRef: React.RefObject<HTMLElement | null>;\n  headerOffset: number;\n  onItemClick?: (id: string) => void;\n}) {\n  const itemRef = useRef<HTMLAnchorElement>(null);\n  const wasActiveRef = useRef(false);\n\n  // Auto-scroll TOC container when this item becomes active\n  useLayoutEffect(() => {\n    if (\n      isActive &&\n      !wasActiveRef.current &&\n      itemRef.current &&\n      containerRef.current\n    ) {\n      const container = containerRef.current;\n      const itemEl = itemRef.current;\n      const containerRect = container.getBoundingClientRect();\n      const itemRect = itemEl.getBoundingClientRect();\n\n      if (\n        itemRect.top < containerRect.top ||\n        itemRect.bottom > containerRect.bottom\n      ) {\n        itemEl.scrollIntoView({ behavior: \"smooth\", block: \"center\" });\n      }\n    }\n    wasActiveRef.current = isActive;\n  }, [isActive, containerRef]);\n\n  // Handle click - scroll content and update URL\n  const handleClick = (e: React.MouseEvent) => {\n    e.preventDefault();\n\n    const elementId = toElementId(item.id);\n    const element = document.getElementById(elementId);\n\n    if (element) {\n      // Update URL first\n      window.history.pushState(null, \"\", `#${elementId}`);\n\n      // Notify parent to set active (with scroll lock)\n      onItemClick?.(item.id);\n\n      // Scroll to element with offset\n      const top =\n        element.getBoundingClientRect().top + window.scrollY - headerOffset;\n      window.scrollTo({ top, behavior: \"smooth\" });\n    }\n  };\n\n  return (\n    <a\n      ref={itemRef}\n      href={`#${toElementId(item.id)}`}\n      onClick={handleClick}\n      className={cn(\n        \"block text-sm py-1.5 transition-colors hover:text-foreground\",\n        item.level === 1 && \"pl-0\",\n        item.level === 2 && \"pl-4\",\n        item.level === 3 && \"pl-8 text-xs\",\n        isActive\n          ? \"text-foreground font-medium underline underline-offset-4\"\n          : \"text-muted-foreground\"\n      )}\n    >\n      {item.text}\n    </a>\n  );\n}\n\n/** Desktop TOC sidebar */\nexport function DesktopTOC({\n  toc,\n  config = {},\n}: {\n  toc: TOCEntry[];\n  config?: TOCConfig;\n}) {\n  const headerOffset = config.headerOffset ?? DEFAULT_HEADER_OFFSET;\n  const { activeId, setActiveWithScroll } = useActiveAnchor(toc, headerOffset);\n  const containerRef = useRef<HTMLDivElement>(null);\n\n  if (toc.length === 0) return null;\n\n  return (\n    <div className=\"sticky top-24\">\n      <h4 className=\"text-sm font-semibold text-foreground mb-4 flex items-center gap-2\">\n        <List className=\"h-4 w-4\" />\n        On this page\n      </h4>\n      <div\n        ref={containerRef}\n        className=\"max-h-[calc(100vh-12rem)] overflow-y-auto scrollbar-thin\"\n      >\n        <nav className=\"space-y-0.5\">\n          {toc.map((item) => (\n            <TOCItem\n              key={item.id}\n              item={item}\n              isActive={activeId === item.id}\n              containerRef={containerRef}\n              headerOffset={headerOffset}\n              onItemClick={setActiveWithScroll}\n            />\n          ))}\n        </nav>\n      </div>\n    </div>\n  );\n}\n\n/** Mobile TOC with Sheet */\nexport function MobileTOC({\n  toc,\n  config = {},\n}: {\n  toc: TOCEntry[];\n  config?: TOCConfig;\n}) {\n  const [open, setOpen] = useState(false);\n  const headerOffset = config.headerOffset ?? DEFAULT_HEADER_OFFSET;\n  const mobileTopClass = config.mobileTopClass ?? \"top-16\";\n  const { activeId, setActiveWithScroll } = useActiveAnchor(toc, headerOffset);\n  const containerRef = useRef<HTMLDivElement>(null);\n\n  if (toc.length === 0) return null;\n\n  const activeItem = toc.find((item) => item.id === activeId);\n\n  const handleItemClick = (id: string) => {\n    setActiveWithScroll(id);\n    setOpen(false);\n  };\n\n  return (\n    <div\n      className={cn(\n        \"lg:hidden sticky z-40 -mx-4 px-4 py-3 mb-6\",\n        \"bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60 border-b border-border\",\n        mobileTopClass\n      )}\n    >\n      <Sheet open={open} onOpenChange={setOpen}>\n        <SheetTrigger asChild>\n          <Button\n            variant=\"outline\"\n            size=\"sm\"\n            className=\"w-full justify-start gap-2 text-muted-foreground hover:text-foreground\"\n          >\n            <List className=\"h-4 w-4 shrink-0\" />\n            <span className=\"truncate\">\n              {activeItem?.text || \"On this page\"}\n            </span>\n          </Button>\n        </SheetTrigger>\n        <SheetContent side=\"left\" className=\"w-80 sm:w-96\">\n          <SheetHeader>\n            <SheetTitle className=\"flex items-center gap-2\">\n              <List className=\"h-4 w-4\" />\n              On this page\n            </SheetTitle>\n          </SheetHeader>\n          <ScrollArea className=\"h-[calc(100vh-8rem)]\">\n            <div ref={containerRef} className=\"px-4 py-2\">\n              <nav className=\"space-y-0.5\">\n                {toc.map((item) => (\n                  <TOCItem\n                    key={item.id}\n                    item={item}\n                    isActive={activeId === item.id}\n                    containerRef={containerRef}\n                    headerOffset={headerOffset}\n                    onItemClick={handleItemClick}\n                  />\n                ))}\n              </nav>\n            </div>\n          </ScrollArea>\n        </SheetContent>\n      </Sheet>\n    </div>\n  );\n}\n\n/** Combined TOC component */\nexport function TableOfContents({\n  toc,\n  config,\n  className,\n}: TableOfContentsProps) {\n  if (toc.length === 0) return null;\n\n  return (\n    <div className={className}>\n      <MobileTOC toc={toc} config={config} />\n      <aside className=\"hidden lg:block w-64 shrink-0\">\n        <DesktopTOC toc={toc} config={config} />\n      </aside>\n    </div>\n  );\n}\n",
      "type": "registry:component",
      "target": "components/notion/table-of-contents.tsx"
    },
    {
      "path": "lib/notion/config.ts",
      "content": "import type { NotionConfig, NotionSourceConfig } from \"@/components/notion/types\";\n\n/**\n * Define your Notion configuration with multiple content sources.\n * Each source can power a different section of your site (blog, changelog, etc.)\n */\nexport function defineNotionConfig(config: NotionConfig): NotionConfig {\n  // Validate required fields\n  if (!config.apiKey) {\n    throw new Error(\"Notion API key is required\");\n  }\n\n  if (!config.sources || Object.keys(config.sources).length === 0) {\n    throw new Error(\"At least one source must be defined\");\n  }\n\n  // Filter out sources with missing databaseId (optional sources)\n  const validSources: Record<string, NotionSourceConfig> = {};\n  for (const [name, source] of Object.entries(config.sources)) {\n    if (!source.databaseId) {\n      console.warn(`Source \"${name}\" skipped: missing databaseId`);\n      continue;\n    }\n    if (!source.basePath) {\n      console.warn(`Source \"${name}\" skipped: missing basePath`);\n      continue;\n    }\n    validSources[name] = source;\n  }\n\n  if (Object.keys(validSources).length === 0) {\n    throw new Error(\"At least one valid source with databaseId is required\");\n  }\n\n  return {\n    ...config,\n    sources: validSources,\n  };\n}\n\n/**\n * Get a specific source configuration by name\n */\nexport function getSource(config: NotionConfig, name: string): NotionSourceConfig {\n  const source = config.sources[name];\n  if (!source) {\n    throw new Error(\n      `Source \"${name}\" not found. Available sources: ${Object.keys(config.sources).join(\", \")}`\n    );\n  }\n  return source;\n}\n\n/**\n * Default posts per page if not specified in source config\n */\nexport const DEFAULT_POSTS_PER_PAGE = 3;\n\n/**\n * Get posts per page for a source, falling back to default\n */\nexport function getPostsPerPage(source: NotionSourceConfig): number {\n  return source.postsPerPage ?? DEFAULT_POSTS_PER_PAGE;\n}\n",
      "type": "registry:lib",
      "target": "lib/notion/config.ts"
    },
    {
      "path": "lib/notion/notion-client.ts",
      "content": "import { Client } from \"@notionhq/client\";\nimport { NotionCompatAPI } from \"notion-compat\";\n\nexport interface NotionClients {\n  client: Client;\n  compatClient: NotionCompatAPI;\n}\n\n/**\n * Create Notion API clients from an API key.\n * Returns both the official client and the compat client for page rendering.\n */\nexport function createNotionClient(apiKey: string): NotionClients {\n  if (!apiKey) {\n    throw new Error(\"Notion API key is required\");\n  }\n\n  const client = new Client({ auth: apiKey });\n  const compatClient = new NotionCompatAPI(client);\n\n  return { client, compatClient };\n}\n",
      "type": "registry:lib",
      "target": "lib/notion/notion-client.ts"
    },
    {
      "path": "lib/notion/notion.ts",
      "content": "import { cache } from \"react\";\nimport { Client } from \"@notionhq/client\";\nimport { NotionCompatAPI } from \"notion-compat\";\nimport { getPageTableOfContents } from \"notion-utils\";\nimport {\n  PageObjectResponse,\n  RichTextItemResponse,\n} from \"@notionhq/client/build/src/api-endpoints\";\nimport type { PageInfo, Tag, TOCEntry } from \"@/components/notion/types\";\nimport { findPageBlock } from \"./notion-utils\";\n\n/**\n * Get a full page with content for rendering.\n * Uses NotionCompatAPI to get the ExtendedRecordMap format needed by react-notion-x.\n */\nexport const getPage = async (\n  compatClient: NotionCompatAPI,\n  pageId: string,\n  allTags?: Tag[]\n) => {\n  const recordMap = await compatClient.getPage(pageId);\n  const rawPage = (recordMap as any).raw?.page;\n  const properties = rawPage?.properties || {};\n\n  // Extract common page properties\n  const pageInfo: PageInfo = {\n    id: rawPage?.id || \"\",\n    title: properties?.Name?.title?.[0]?.plain_text || \"No title\",\n    description: properties?.Description?.rich_text?.[0]?.plain_text || \"\",\n    createdAt: rawPage?.created_time || \"\",\n    lastEditedAt: rawPage?.last_edited_time || \"\",\n    cover:\n      rawPage?.cover?.type === \"external\"\n        ? rawPage.cover.external.url\n        : rawPage?.cover?.file?.url,\n    icon:\n      rawPage?.icon?.type === \"emoji\"\n        ? rawPage.icon.emoji\n        : rawPage?.icon?.file?.url || null,\n  };\n\n  // Process tags if provided\n  let blogTags: Tag[] = [];\n  if (rawPage && allTags) {\n    const tagIds = properties?.Tags?.relation?.map((r: any) => r.id) || [];\n    blogTags = allTags.filter((tag) => tagIds.includes(tag.id));\n  }\n\n  // Extract table of contents from headings\n  let toc: TOCEntry[] = [];\n  try {\n    const pageBlock = findPageBlock(recordMap);\n    if (pageBlock) {\n      const rawToc = getPageTableOfContents(pageBlock, recordMap);\n      toc = rawToc.map((item) => ({\n        id: item.id,\n        text: item.text,\n        level: item.indentLevel + 1, // Convert 0,1,2 to 1,2,3 for h1,h2,h3\n      }));\n    }\n  } catch (error) {\n    console.error(\"Error extracting TOC:\", error);\n  }\n\n  return {\n    ...recordMap,\n    pageInfo: {\n      ...pageInfo,\n      tags: blogTags,\n      cover: pageInfo.cover,\n      toc,\n    },\n    raw: {\n      ...(recordMap as any).raw,\n      page: rawPage,\n    },\n  } as typeof recordMap & {\n    pageInfo: PageInfo & { toc: TOCEntry[] };\n    raw: {\n      page: PageObjectResponse;\n    };\n  };\n};\n\n/**\n * Get all tags from a tags database.\n */\nexport const getTags = cache(async function getTags(\n  client: Client,\n  tagDatabaseId: string\n): Promise<Tag[]> {\n  const response = await client.databases.query({\n    database_id: tagDatabaseId,\n  });\n\n  return response.results.map((page: any) => ({\n    id: page.id,\n    value: page.properties.Slug.rich_text[0]?.plain_text || \"\",\n    label: page.properties.Name.title[0]?.plain_text || \"\",\n  }));\n});\n\n/**\n * Get all published posts from a database.\n * Filters by Published status = \"Done\".\n * Sorted by created_time descending (newest first).\n */\nexport const getPublishedPosts = cache(async function getPublishedPosts(client: Client, databaseId: string) {\n  return client.databases.query({\n    database_id: databaseId,\n    filter: {\n      property: \"Published\",\n      status: { equals: \"Done\" },\n    },\n    sorts: [\n      {\n        timestamp: \"created_time\",\n        direction: \"descending\",\n      },\n    ],\n  });\n});\n\n/**\n * Get all authors from an author database.\n */\nexport const getAuthors = cache(async function getAuthors(\n  client: Client,\n  authorDatabaseId: string\n): Promise<{ id: string; name: string }[]> {\n  const response = await client.databases.query({\n    database_id: authorDatabaseId,\n  });\n\n  return response.results.map((page: any) => ({\n    id: page.id,\n    name: page.properties.Name?.title?.[0]?.plain_text || \"Unknown\",\n  }));\n});\n\n/**\n * Get a page by its slug from a database.\n */\nexport const getPageBySlug = cache(async function getPageBySlug(\n  client: Client,\n  databaseId: string,\n  slug: string\n) {\n  const response = await client.databases.query({\n    database_id: databaseId,\n    filter: {\n      property: \"Slug\",\n      rich_text: { equals: slug },\n    },\n  });\n  return response.results[0];\n});\n\n/**\n * Extract page info from a PageObjectResponse.\n */\nexport function getPageInfo(page: PageObjectResponse): PageInfo {\n  const properties = page.properties;\n\n  const getIconUrl = () => {\n    if (!page.icon) return null;\n\n    switch (page.icon.type) {\n      case \"emoji\":\n        return page.icon.emoji;\n      case \"external\":\n        return page.icon.external.url;\n      case \"file\":\n        return page.icon.file.url;\n      default:\n        return null;\n    }\n  };\n\n  return {\n    id: page.id,\n    title:\n      properties?.Name?.type === \"title\"\n        ? getPlainText(properties.Name.title)\n        : \"No title\",\n    description:\n      properties?.Description?.type === \"rich_text\"\n        ? getPlainText(properties.Description.rich_text)\n        : \"\",\n    createdAt: page.created_time,\n    lastEditedAt: page.last_edited_time,\n    cover:\n      page.cover?.type === \"external\"\n        ? page.cover.external.url\n        : (page.cover as any)?.file?.url,\n    icon: getIconUrl(),\n  };\n}\n\n/**\n * Extract plain text from rich text array.\n */\nexport function getPlainText(rich: RichTextItemResponse[]): string {\n  return rich.map((v) => v.plain_text).join();\n}\n",
      "type": "registry:lib",
      "target": "lib/notion/notion.ts"
    },
    {
      "path": "lib/notion/notion-mappers.ts",
      "content": "import type {\n  Author,\n  ContentItem,\n  NotionPage,\n  Tag,\n} from \"@/components/notion/types\";\n\n/**\n * Type guard to check if an object is a valid Notion page.\n */\nexport function isNotionPage(page: unknown): page is NotionPage {\n  return page !== null && typeof page === \"object\" && \"properties\" in page;\n}\n\n/**\n * Extract cover image URL from a Notion page.\n * Cover can be external URL or uploaded file.\n */\nfunction getCoverUrl(page: NotionPage): string | undefined {\n  const cover = (page as { cover?: { type: string; external?: { url: string }; file?: { url: string } } }).cover;\n  if (!cover) return undefined;\n\n  if (cover.type === \"external\" && cover.external?.url) {\n    return cover.external.url;\n  }\n  if (cover.type === \"file\" && cover.file?.url) {\n    return cover.file.url;\n  }\n  return undefined;\n}\n\n/**\n * Extract author name(s) from a Notion page.\n * Author can be either a \"people\" property or a \"relation\" to an Author database.\n * Supports multiple authors, joined by comma.\n */\nfunction getAuthor(page: NotionPage, authors: Author[]): string | undefined {\n  const authorProp = page.properties.Author;\n  if (!authorProp) return undefined;\n\n  // People type - join all names\n  if (authorProp.people && authorProp.people.length > 0) {\n    const names = authorProp.people\n      .map((p) => p.name)\n      .filter((name): name is string => Boolean(name));\n    return names.length > 0 ? names.join(\", \") : undefined;\n  }\n\n  // Relation type - look up all authors in authors array\n  if (authorProp.relation && authorProp.relation.length > 0) {\n    const names = authorProp.relation\n      .map((r) => authors.find((a) => a.id === r.id)?.name)\n      .filter((name): name is string => Boolean(name));\n    return names.length > 0 ? names.join(\", \") : undefined;\n  }\n\n  return undefined;\n}\n\n/**\n * Map a Notion page to a ContentItem object.\n * @param page - The Notion page object\n * @param tags - Available tags to resolve tag relations\n * @param basePath - Base path for the content URL (e.g., '/blog', '/changelog')\n * @param authors - Optional authors array to resolve author relations\n */\nexport function mapNotionPageToContentItem(\n  page: unknown,\n  tags: Tag[] = [],\n  basePath: string = \"/blog\",\n  authors: Author[] = []\n): ContentItem | null {\n  if (!isNotionPage(page)) return null;\n\n  // Extract tag IDs and resolve to labels\n  const tagIds = page.properties.Tags?.relation?.map((r) => r.id) ?? [];\n  const pageTags = tags\n    .filter((tag) => tagIds.includes(tag.id))\n    .map((tag) => tag.label);\n\n  // Extract basic properties\n  const title = page.properties.Name?.title?.[0]?.plain_text ?? \"Untitled\";\n  const description = page.properties.Description?.rich_text?.[0]?.plain_text ?? \"\";\n  const date = page.properties.Date?.date?.start ?? new Date().toISOString();\n  const slug = page.properties.Slug?.rich_text?.[0]?.plain_text ?? page.id;\n\n  // Extract author and cover\n  const author = getAuthor(page, authors);\n  const cover = getCoverUrl(page);\n\n  // Ensure required fields are present\n  if (!title || !description || !date) {\n    console.warn(`Skipping page ${page.id} due to missing required fields`);\n    return null;\n  }\n\n  return {\n    id: page.id,\n    url: `${basePath}/${slug}`,\n    data: {\n      title,\n      description,\n      date,\n      author,\n      tags: pageTags,\n      cover,\n    },\n  };\n}\n\n// Alias for backward compatibility\nexport { mapNotionPageToContentItem as mapNotionPostToBlogPost };\n",
      "type": "registry:lib",
      "target": "lib/notion/notion-mappers.ts"
    },
    {
      "path": "lib/notion/notion-utils.ts",
      "content": "import type { Block, PageBlock, ExtendedRecordMap } from \"notion-types\";\n\nexport const isPageBlock = (block: Block): block is PageBlock => {\n  return block.type === \"page\";\n};\n\nexport const findPageBlock = (recordMap: ExtendedRecordMap): PageBlock | null => {\n  for (const blockId in recordMap.block) {\n    const block = recordMap.block[blockId]?.value;\n    if (block && isPageBlock(block)) {\n      return block;\n    }\n  }\n  return null;\n};\n",
      "type": "registry:lib",
      "target": "lib/notion/notion-utils.ts"
    },
    {
      "path": "lib/notion/page-utils.ts",
      "content": "/**\n * Helper functions to determine page types based on URL parameters\n */\n\ntype PageParams = { slug?: string[] };\n\n/**\n * Checks if the current route is the root page (no slug)\n */\nexport function isRootPage(params: PageParams): boolean {\n  return !params.slug || params.slug.length === 0;\n}\n\n// Alias for backward compatibility\nexport { isRootPage as isBlogRootPage };\n\n/**\n * Checks if the current route is a tag page\n */\nexport function isTagPage(params: PageParams): boolean {\n  return (\n    !!params.slug &&\n    params.slug.length >= 2 &&\n    params.slug[0] === \"tag\" &&\n    !!params.slug[1]\n  );\n}\n\n/**\n * Checks if the current route is a paginated tag page\n */\nexport function isPaginatedTagPage(params: PageParams): boolean {\n  return (\n    !!params.slug &&\n    params.slug.length === 4 &&\n    params.slug[0] === \"tag\" &&\n    !!params.slug[1] &&\n    params.slug[2] === \"page\" &&\n    !isNaN(Number(params.slug[3]))\n  );\n}\n\n/**\n * Checks if the current route is an individual content page (single slug)\n */\nexport function isContentPage(params: PageParams): boolean {\n  return !!params.slug && params.slug.length === 1 && !!params.slug[0];\n}\n\n// Alias for backward compatibility\nexport { isContentPage as isBlogPostPage };\n\n/**\n * Checks if the current route is a paginated list\n */\nexport function isPaginatedPage(params: PageParams): boolean {\n  return (\n    !!params.slug &&\n    params.slug.length === 2 &&\n    params.slug[0] === \"page\" &&\n    !isNaN(Number(params.slug[1]))\n  );\n}\n\n// Alias for backward compatibility\nexport { isPaginatedPage as isPaginatedBlogPage };\n\n/**\n * Gets the tag slug from params if it's a tag page\n */\nexport function getTagSlug(params: PageParams): string | null {\n  if (isTagPage(params) || isPaginatedTagPage(params)) {\n    return params.slug?.[1] || null;\n  }\n  return null;\n}\n\n/**\n * Gets the page number from params if it's a paginated page\n */\nexport function getPageNumber(params: PageParams): number {\n  if (isPaginatedPage(params)) {\n    return Number(params.slug?.[1]) || 1;\n  }\n  if (isPaginatedTagPage(params)) {\n    return Number(params.slug?.[3]) || 1;\n  }\n  return 1;\n}\n\n/**\n * Gets the content slug from params if it's a content page\n */\nexport function getContentSlug(params: PageParams): string | null {\n  if (isContentPage(params)) {\n    return params.slug?.[0] || null;\n  }\n  return null;\n}\n\n// Alias for backward compatibility\nexport { getContentSlug as getPostSlug };\n",
      "type": "registry:lib",
      "target": "lib/notion/page-utils.ts"
    },
    {
      "path": "lib/notion/static-params.ts",
      "content": "import { Client } from \"@notionhq/client\";\nimport { getPublishedPosts, getTags } from \"./notion\";\nimport { isNotionPage } from \"./notion-mappers\";\nimport { getPostsPerPage } from \"./config\";\nimport type { NotionSourceConfig, Tag } from \"@/components/notion/types\";\n\ntype StaticParam = { slug: string[] };\n\n/**\n * Generate static params for a Notion content source.\n * This enables static generation for all routes at build time.\n */\nexport async function generateStaticParams(\n  client: Client,\n  source: NotionSourceConfig\n): Promise<StaticParam[]> {\n  const allParams: StaticParam[] = [];\n  const postsPerPage = getPostsPerPage(source);\n\n  // Add root route (slug: [])\n  allParams.push({ slug: [] });\n\n  // 1. Get all published posts\n  const { results: posts } = await getPublishedPosts(client, source.databaseId);\n\n  // 2. Generate root pagination paths (/page/2, etc.)\n  const rootParams = generateRootPathParams(posts.length, postsPerPage);\n  allParams.push(...rootParams);\n\n  // 3. Generate individual post paths (/{slug})\n  const postParams = generatePostPathParams(posts);\n  allParams.push(...postParams);\n\n  // 4. Generate tag paths if tag database is configured\n  if (source.tagDatabaseId) {\n    const tagParams = await generateTagPathParams(\n      client,\n      source.tagDatabaseId,\n      posts,\n      postsPerPage\n    );\n    allParams.push(...tagParams);\n  }\n\n  return allParams;\n}\n\nfunction generateRootPathParams(\n  totalPosts: number,\n  postsPerPage: number\n): StaticParam[] {\n  const totalPages = Math.ceil(totalPosts / postsPerPage);\n  const params: StaticParam[] = [];\n\n  // Skip page 1 as it's handled by the root route\n  for (let i = 1; i < totalPages; i++) {\n    params.push({ slug: [\"page\", (i + 1).toString()] });\n  }\n\n  return params;\n}\n\nfunction generatePostPathParams(posts: any[]): StaticParam[] {\n  return posts\n    .filter((post) => \"properties\" in post)\n    .filter((post) => {\n      const slugProp = post.properties.Slug;\n      return (\n        slugProp?.type === \"rich_text\" &&\n        Array.isArray(slugProp.rich_text) &&\n        slugProp.rich_text.length > 0\n      );\n    })\n    .map((post) => ({\n      slug: [post.properties.Slug.rich_text[0].plain_text],\n    }));\n}\n\nasync function generateTagPathParams(\n  client: Client,\n  tagDatabaseId: string,\n  posts: any[],\n  postsPerPage: number\n): Promise<StaticParam[]> {\n  const tags = await getTags(client, tagDatabaseId);\n\n  const allParams: StaticParam[] = [];\n  const tagPostCounts = new Map<string, number>();\n\n  // Count posts per tag\n  for (const post of posts) {\n    if (isNotionPage(post)) {\n      const tagsProperty = post.properties.Tags;\n      if (tagsProperty) {\n        const tagIds = tagsProperty.relation?.map((r) => r.id) || [];\n        tagIds.forEach((tagId: string) => {\n          tagPostCounts.set(tagId, (tagPostCounts.get(tagId) || 0) + 1);\n        });\n      }\n    }\n  }\n\n  // Generate paths for each tag\n  for (const tag of tags) {\n    const postCount = tagPostCounts.get(tag.id) || 0;\n\n    if (postCount === 0) continue;\n\n    // Add tag page (/tag/{tag-slug})\n    allParams.push({ slug: [\"tag\", tag.value] });\n\n    // Add pagination pages if needed (/tag/{tag-slug}/page/2, etc.)\n    const totalPages = Math.ceil(postCount / postsPerPage);\n    for (let i = 1; i < totalPages; i++) {\n      allParams.push({\n        slug: [\"tag\", tag.value, \"page\", (i + 1).toString()],\n      });\n    }\n  }\n\n  return allParams;\n}\n",
      "type": "registry:lib",
      "target": "lib/notion/static-params.ts"
    },
    {
      "path": "lib/notion/content-page.tsx",
      "content": "import type { Client } from \"@notionhq/client\";\nimport type { NotionCompatAPI } from \"notion-compat\";\nimport type { ComponentType } from \"react\";\nimport type { Metadata } from \"next\";\nimport type {\n  NotionPage,\n  NotionSourceConfig,\n  Tag,\n  TOCConfig,\n  Author,\n  CustomListComponentProps,\n  CustomPageComponentProps,\n  ContentItem,\n} from \"@/components/notion/types\";\nimport { getPage, getPageBySlug, getPublishedPosts, getTags, getAuthors } from \"@/lib/notion/notion\";\nimport { generateStaticParams } from \"@/lib/notion/static-params\";\nimport { getPostsPerPage } from \"@/lib/notion/config\";\nimport { ContentList } from \"@/components/notion/content-list\";\nimport { ContentPage } from \"@/components/notion/content-page\";\nimport { mapNotionPageToContentItem } from \"@/lib/notion/notion-mappers\";\nimport {\n  isRootPage,\n  isContentPage,\n  isTagPage,\n  isPaginatedTagPage,\n  isPaginatedPage,\n  getTagSlug,\n  getContentSlug,\n} from \"@/lib/notion/page-utils\";\n\nexport interface ContentPageOptions {\n  source: NotionSourceConfig;\n  client: Client;\n  compatClient: NotionCompatAPI;\n  /** Heading for the list page (default: \"Latest\") */\n  listHeading?: string;\n  /** Heading prefix for tag pages (default: \"Tagged with:\") */\n  tagHeadingPrefix?: string;\n  /** Label for content items (default: \"Post\") */\n  contentLabel?: string;\n  /** TOC configuration for header offset and mobile positioning */\n  tocConfig?: TOCConfig;\n  /** Author database ID for resolving author relations */\n  authorDatabaseId?: string;\n  /** Custom component for list pages (replaces default ContentList) */\n  ListComponent?: ComponentType<CustomListComponentProps>;\n  /** Custom component for detail pages (replaces default ContentPage) */\n  PageComponent?: ComponentType<CustomPageComponentProps>;\n  /** Site name for metadata (used in og:site_name) */\n  siteName?: string;\n  /** Base URL for canonical URLs and OG images */\n  baseUrl?: string;\n  /** Base path for OG image generation (e.g., \"blog-og\" for /blog-og/[slug]/image.png) */\n  ogImageBase?: string;\n  /**\n   * Transform metadata before returning. Use this to integrate with your own\n   * metadata utilities like createMetadata().\n   *\n   * @example\n   * transformMetadata: (meta) => createMetadata({\n   *   ...meta,\n   *   title: `${meta.title} | My Site`,\n   * })\n   */\n  transformMetadata?: (metadata: Metadata) => Metadata;\n}\n\n/**\n * Creates page handlers for a Notion content source.\n * Returns generateStaticParams and Page component for use in Next.js app router.\n */\nexport function createContentSource(options: ContentPageOptions) {\n  const {\n    source,\n    client,\n    compatClient,\n    listHeading = \"Latest\",\n    tagHeadingPrefix = \"Tagged with:\",\n    contentLabel = \"Post\",\n    tocConfig,\n    authorDatabaseId,\n    ListComponent,\n    PageComponent,\n    siteName,\n    baseUrl,\n    ogImageBase,\n    transformMetadata = (m) => m, // Default: pass through unchanged\n  } = options;\n\n  // Helper to generate OG image URLs\n  const getOgImageUrl = (slugParts: string[] = []): string | undefined => {\n    if (!ogImageBase) return undefined;\n    const slugPath = slugParts.length > 0 ? `/${slugParts.join(\"/\")}` : \"\";\n    return `/${ogImageBase}${slugPath}/image.png`;\n  };\n\n  // Helper to format image metadata\n  const getImageMetadata = (url: string) => ({\n    url,\n    width: 1200,\n    height: 630,\n    alt: siteName || \"MFStack\",\n  });\n\n  // Generate static params for this source\n  async function generateParams() {\n    return generateStaticParams(client, source);\n  }\n\n  // Generate metadata for SEO\n  async function generateMeta(props: {\n    params: Promise<{ slug?: string[] }>;\n  }): Promise<Metadata> {\n    const params = await props.params;\n    const { slug = [] } = params;\n    const pageParams = { slug };\n\n    // List page metadata\n    if (isRootPage(pageParams) || isPaginatedPage(pageParams)) {\n      const pageNum = isPaginatedPage(pageParams)\n        ? parseInt(slug[slug.length - 1], 10)\n        : 1;\n      const title = pageNum > 1 ? `${listHeading} - Page ${pageNum}` : listHeading;\n      const ogImageUrl = getOgImageUrl();\n      const description = `Browse all ${contentLabel.toLowerCase()}s`;\n      const canonical = baseUrl ? `${baseUrl}${source.basePath}${pageNum > 1 ? `/page/${pageNum}` : \"\"}` : undefined;\n\n      return transformMetadata({\n        title,\n        description,\n        openGraph: {\n          title,\n          description,\n          type: \"website\",\n          siteName,\n          images: ogImageUrl ? [getImageMetadata(ogImageUrl)] : undefined,\n        },\n        twitter: {\n          card: \"summary_large_image\",\n          title,\n          description,\n          images: ogImageUrl ? [ogImageUrl] : undefined,\n        },\n        alternates: canonical ? { canonical } : undefined,\n      });\n    }\n\n    // Tag page metadata\n    if (isTagPage(pageParams) || isPaginatedTagPage(pageParams)) {\n      const tagSlug = getTagSlug(pageParams);\n      const tags = source.tagDatabaseId\n        ? await getTags(client, source.tagDatabaseId)\n        : [];\n      const tag = tags.find((t) => t.value === tagSlug);\n      const tagName = tag?.label ?? tagSlug;\n      const title = `${tagHeadingPrefix} ${tagName}`;\n      const description = `${contentLabel}s tagged with ${tagName}`;\n      const ogImageUrl = getOgImageUrl([\"tag\", tagSlug]);\n      const canonical = baseUrl ? `${baseUrl}${source.basePath}/tag/${tagSlug}` : undefined;\n\n      return transformMetadata({\n        title,\n        description,\n        openGraph: {\n          title,\n          description,\n          type: \"website\",\n          siteName,\n          images: ogImageUrl ? [getImageMetadata(ogImageUrl)] : undefined,\n        },\n        twitter: {\n          card: \"summary_large_image\",\n          title,\n          description,\n          images: ogImageUrl ? [ogImageUrl] : undefined,\n        },\n        alternates: canonical ? { canonical } : undefined,\n      });\n    }\n\n    // Content page metadata\n    if (isContentPage(pageParams)) {\n      const contentSlug = getContentSlug(pageParams);\n      if (!contentSlug) {\n        return transformMetadata({ title: \"Not Found\" });\n      }\n\n      const post = await getPageBySlug(client, source.databaseId, contentSlug);\n      if (!post) {\n        return transformMetadata({ title: `${contentLabel} Not Found` });\n      }\n\n      const title = (post as NotionPage).properties?.Name?.title?.[0]?.plain_text ?? \"Untitled\";\n      const description = (post as NotionPage).properties?.Description?.rich_text?.[0]?.plain_text ?? \"\";\n      const cover = (post as { cover?: { external?: { url: string }; file?: { url: string } } }).cover;\n      const coverUrl = cover?.external?.url ?? cover?.file?.url;\n\n      const canonical = baseUrl ? `${baseUrl}${source.basePath}/${contentSlug}` : undefined;\n\n      // Prefer generated OG image over cover image\n      const ogImageUrl = getOgImageUrl([contentSlug]);\n      const imageUrl = ogImageUrl || coverUrl;\n\n      return transformMetadata({\n        title,\n        description,\n        openGraph: {\n          title,\n          description,\n          type: \"article\",\n          siteName,\n          images: imageUrl ? [ogImageUrl ? getImageMetadata(imageUrl) : { url: imageUrl }] : undefined,\n        },\n        twitter: {\n          card: imageUrl ? \"summary_large_image\" : \"summary\",\n          title,\n          description,\n          images: imageUrl ? [imageUrl] : undefined,\n        },\n        alternates: canonical ? { canonical } : undefined,\n      });\n    }\n\n    return transformMetadata({ title: listHeading });\n  }\n\n  // Main page component\n  async function Page(props: { params: Promise<{ slug?: string[] }> }) {\n    const params = await props.params;\n    const { slug = [] } = params;\n    const pageParams = { slug };\n\n    // Fetch data\n    const postsResponse = await getPublishedPosts(client, source.databaseId);\n    const posts = (\n      Array.isArray(postsResponse) ? postsResponse : postsResponse.results || []\n    ) as NotionPage[];\n\n    const tags: Tag[] = source.tagDatabaseId\n      ? await getTags(client, source.tagDatabaseId)\n      : [];\n\n    const authors: Author[] = authorDatabaseId\n      ? await getAuthors(client, authorDatabaseId)\n      : [];\n\n    const postsPerPage = getPostsPerPage(source);\n\n    // Helper to map posts to content items\n    const mapPosts = (postsToMap: NotionPage[]): ContentItem[] =>\n      postsToMap\n        .map((p) => mapNotionPageToContentItem(p, tags, source.basePath, authors))\n        .filter((item): item is ContentItem => item !== null);\n\n    // Helper to get pagination info\n    const getPageNumber = (params: { slug?: string[] }): number => {\n      if (!params.slug || params.slug.length === 0) return 1;\n      const page = parseInt(params.slug[params.slug.length - 1], 10);\n      return isNaN(page) ? 1 : Math.max(1, page);\n    };\n\n    // Handle individual content page\n    if (isContentPage(pageParams)) {\n      const contentSlug = getContentSlug(pageParams);\n      if (!contentSlug) {\n        return <div className=\"max-w-3xl mx-auto p-4\">Invalid URL</div>;\n      }\n\n      const post = await getPageBySlug(client, source.databaseId, contentSlug);\n      if (!post) {\n        return <div className=\"max-w-3xl mx-auto p-4\">{contentLabel} not found</div>;\n      }\n      const recordMap = await getPage(compatClient, post.id, tags);\n\n      // Use custom component if provided\n      if (PageComponent) {\n        return <PageComponent recordMap={recordMap} basePath={source.basePath} tocConfig={tocConfig} />;\n      }\n      return <ContentPage recordMap={recordMap} basePath={source.basePath} tocConfig={tocConfig} />;\n    }\n\n    // Handle tag pages\n    if (isTagPage(pageParams) || isPaginatedTagPage(pageParams)) {\n      const tagSlug = getTagSlug(pageParams);\n      if (!tagSlug) {\n        return <div className=\"max-w-3xl mx-auto p-4\">Invalid tag URL</div>;\n      }\n\n      const tag = tags.find((t) => t.value === tagSlug);\n      if (!tag) {\n        return <div className=\"max-w-3xl mx-auto p-4\">Tag not found</div>;\n      }\n\n      const taggedPosts = posts.filter((post) => {\n        const postTags = post.properties?.Tags?.relation || [];\n        return postTags.some((t: { id: string }) => t.id === tag.id);\n      });\n\n      // Use custom component if provided\n      if (ListComponent) {\n        const items = mapPosts(taggedPosts);\n        const currentPage = getPageNumber(pageParams);\n        const totalPages = Math.ceil(items.length / postsPerPage);\n        return (\n          <ListComponent\n            items={items.slice((currentPage - 1) * postsPerPage, currentPage * postsPerPage)}\n            tags={tags}\n            currentPage={currentPage}\n            totalPages={totalPages}\n            heading={`${tagHeadingPrefix} ${tag.label}`}\n            basePath={`${source.basePath}/tag/${tag.value}`}\n          />\n        );\n      }\n\n      return (\n        <ContentList\n          posts={taggedPosts}\n          tags={tags}\n          authors={authors}\n          pageParams={pageParams}\n          isPaginated={true}\n          heading={`${tagHeadingPrefix} ${tag.label}`}\n          basePath={`${source.basePath}/tag/${tag.value}`}\n          configuration={{ pageSize: postsPerPage }}\n        />\n      );\n    }\n\n    // Handle root and paginated pages\n    if (isRootPage(pageParams) || isPaginatedPage(pageParams)) {\n      // Use custom component if provided\n      if (ListComponent) {\n        const items = mapPosts(posts);\n        const currentPage = getPageNumber(pageParams);\n        const totalPages = Math.ceil(items.length / postsPerPage);\n        return (\n          <ListComponent\n            items={items.slice((currentPage - 1) * postsPerPage, currentPage * postsPerPage)}\n            tags={tags}\n            currentPage={currentPage}\n            totalPages={totalPages}\n            heading={listHeading}\n            basePath={source.basePath}\n          />\n        );\n      }\n\n      return (\n        <ContentList\n          posts={posts}\n          tags={tags}\n          authors={authors}\n          pageParams={pageParams}\n          isPaginated={true}\n          heading={listHeading}\n          basePath={source.basePath}\n          configuration={{ pageSize: postsPerPage }}\n        />\n      );\n    }\n\n    // 404\n    return (\n      <div className=\"max-w-3xl mx-auto p-4\">\n        <h1 className=\"text-3xl font-bold mb-4\">404 - Page Not Found</h1>\n        <p className=\"text-gray-600\">The requested page could not be found.</p>\n      </div>\n    );\n  }\n\n  return { generateStaticParams: generateParams, generateMetadata: generateMeta, Page };\n}\n",
      "type": "registry:lib",
      "target": "lib/notion/content-page.tsx"
    },
    {
      "path": "lib/notion/search.ts",
      "content": "import { Client } from \"@notionhq/client\";\nimport { getPublishedPosts } from \"./notion\";\nimport type { NotionSourceConfig } from \"@/components/notion/types\";\n\n/**\n * Content section structure for search index\n */\nexport interface SearchContent {\n  heading: string;\n  content: string;\n}\n\n/**\n * Heading structure for search index\n */\nexport interface SearchHeading {\n  id: string;\n  content: string;\n}\n\n/**\n * Search index structure compatible with fumadocs-core/search/server AdvancedIndex\n * Define our own type to avoid fumadocs dependency in the registry\n */\nexport interface SearchIndex {\n  id: string;\n  title: string;\n  description?: string;\n  keywords?: string;\n  tag?: string;\n  url: string;\n  structuredData: {\n    headline: string;\n    description: string;\n    contents: SearchContent[];\n    headings: SearchHeading[];\n  };\n}\n\nexport interface SearchIndexCache {\n  indexes: SearchIndex[];\n  lastFetchTime: number;\n}\n\n/**\n * Build search indexes for a content source.\n * This fetches all published posts and converts them to search indexes.\n */\nexport async function buildSearchIndexes(\n  client: Client,\n  source: NotionSourceConfig\n): Promise<SearchIndex[]> {\n  const response = await getPublishedPosts(client, source.databaseId);\n  const posts = Array.isArray(response) ? response : response?.results || [];\n\n  return posts.map((post: any) => ({\n    id: post.id,\n    title: post.properties.Name?.title?.[0]?.plain_text || \"Untitled\",\n    description:\n      post.properties.Description?.rich_text?.[0]?.plain_text || \"\",\n    keywords: post.properties.Keywords?.rich_text?.[0]?.plain_text || \"\",\n    tag: source.basePath.replace(/^\\//, \"\"), // e.g., \"blog\" from \"/blog\"\n    url: `${source.basePath}/${\n      post.properties.Slug?.rich_text?.[0]?.plain_text || post.id\n    }`,\n    structuredData: {\n      headline: post.properties.Name?.title?.[0]?.plain_text || \"Untitled\",\n      description:\n        post.properties.Description?.rich_text?.[0]?.plain_text || \"\",\n      contents: [] as SearchContent[],\n      headings: [] as SearchHeading[],\n    },\n  }));\n}\n\n/**\n * Build search indexes for multiple content sources.\n * Combines indexes from all sources into a single array.\n */\nexport async function buildMultiSourceSearchIndexes(\n  client: Client,\n  sources: Record<string, NotionSourceConfig>\n): Promise<SearchIndex[]> {\n  const allIndexes: SearchIndex[] = [];\n\n  for (const [name, source] of Object.entries(sources)) {\n    try {\n      console.log(`Building search indexes for source: ${name}`);\n      const indexes = await buildSearchIndexes(client, source);\n      allIndexes.push(...indexes);\n    } catch (error) {\n      console.error(`Error building search indexes for ${name}:`, error);\n    }\n  }\n\n  return allIndexes;\n}\n\n/**\n * Create a cached search index fetcher.\n * Returns a function that fetches indexes with optional caching.\n */\nexport function createSearchIndexFetcher(\n  client: Client,\n  sources: Record<string, NotionSourceConfig>,\n  cacheTTL: number = 0 // 0 = no cache\n) {\n  const cache: SearchIndexCache = {\n    indexes: [],\n    lastFetchTime: 0,\n  };\n\n  return async function getSearchIndexes(): Promise<SearchIndex[]> {\n    const now = Date.now();\n\n    // Check if cache is still valid\n    if (cache.indexes.length && cacheTTL > 0 && now - cache.lastFetchTime < cacheTTL) {\n      console.log(\"Returning cached search indexes\");\n      return cache.indexes;\n    }\n\n    console.log(\"Fetching fresh search indexes from Notion\");\n\n    try {\n      cache.indexes = await buildMultiSourceSearchIndexes(client, sources);\n      cache.lastFetchTime = now;\n    } catch (error) {\n      console.error(\"Error fetching search indexes:\", error);\n      cache.indexes = [];\n    }\n\n    console.log(`Search indexes count: ${cache.indexes.length}`);\n    return cache.indexes;\n  };\n}\n",
      "type": "registry:lib",
      "target": "lib/notion/search.ts"
    },
    {
      "path": "components/notion/types.ts",
      "content": "import type { ExtendedRecordMap, PageBlock } from \"notion-types\";\nimport type {\n  PageObjectResponse,\n  DatabaseObjectResponse,\n} from \"@notionhq/client/build/src/api-endpoints\";\n\ntype NotionResponse = PageObjectResponse | DatabaseObjectResponse;\n\n// Configuration types for multi-source support\nexport interface NotionSourceConfig {\n  databaseId: string;\n  tagDatabaseId?: string;\n  basePath: string;\n  postsPerPage?: number;\n}\n\nexport interface NotionConfig {\n  apiKey: string;\n  // Shared author database - can be used by all sources\n  authorDatabaseId?: string;\n  sources: Record<string, NotionSourceConfig>;\n}\n\nexport interface Tag {\n  id: string;\n  value: string;\n  label: string;\n}\n\n// Table of Contents entry extracted from Notion headings\nexport interface TOCEntry {\n  id: string;\n  text: string;\n  level: number; // 1, 2, or 3 for h1, h2, h3\n}\n\n// TOC configuration for customizing behavior\nexport interface TOCConfig {\n  /** Offset from top for scroll spy calculations (default: 100) */\n  headerOffset?: number;\n  /** Mobile sticky bar top position in Tailwind class (default: \"top-16\") */\n  mobileTopClass?: string;\n}\n\nexport interface PageInfo {\n  id: string;\n  title: string;\n  description: string;\n  createdAt: string;\n  lastEditedAt: string;\n  cover?: string;\n  icon?: string | null;\n  tags?: Tag[];\n}\n\nexport type NotionPage = {\n  id: string;\n  properties: {\n    Name?: {\n      title: Array<{ plain_text: string }>;\n    };\n    Description?: {\n      rich_text: Array<{ plain_text: string }>;\n    };\n    Slug?: {\n      rich_text: Array<{ plain_text: string }>;\n    };\n    Date?: {\n      date: { start: string };\n    };\n    Author?: {\n      people?: Array<{ name: string }>;\n      relation?: Array<{ id: string }>;\n    };\n    Tags?: {\n      relation: Array<{ id: string }>;\n    };\n    [key: string]: any;\n  };\n} & ({ object: \"page\" } | { object: \"database\" } | { object: \"block\" });\n\nexport interface NotionPageWithInfo extends ExtendedRecordMap {\n  pageInfo: PageInfo;\n  raw: {\n    page: PageObjectResponse;\n  };\n}\n\n// Generic content item (can be blog post, changelog entry, etc.)\nexport interface ContentItem {\n  id: string;\n  url: string;\n  data: {\n    title: string;\n    description: string;\n    date: string;\n    author: string | undefined;\n    tags: string[];\n    cover?: string;\n  };\n}\n\n// Alias for backward compatibility\nexport type BlogPost = ContentItem;\n\nexport interface ContentConfiguration {\n  pageSize?: number;\n  basePath?: string;\n}\n\n// Alias for backward compatibility\nexport type BlogConfiguration = ContentConfiguration;\n\nexport interface Author {\n  id: string;\n  name: string;\n}\n\nexport interface ContentListProps {\n  posts: NotionPage[];\n  tags: Tag[];\n  authors?: Author[];\n  pageParams: { slug?: string[] };\n  isPaginated: boolean;\n  heading?: string;\n  basePath?: string;\n  configuration?: ContentConfiguration;\n}\n\n// Alias for backward compatibility\nexport type BlogListProps = ContentListProps;\n\nexport interface ContentPageProps {\n  recordMap: NotionPageWithInfo;\n  basePath?: string;\n  tocConfig?: TOCConfig;\n}\n\n// Alias for backward compatibility\nexport type BlogPostProps = ContentPageProps;\n\n// Props passed to custom list components\nexport interface CustomListComponentProps {\n  items: ContentItem[];\n  tags: Tag[];\n  currentPage: number;\n  totalPages: number;\n  heading: string;\n  basePath: string;\n}\n\n// Props passed to custom page components\nexport interface CustomPageComponentProps {\n  recordMap: NotionPageWithInfo;\n  basePath: string;\n  tocConfig?: TOCConfig;\n}\n\nexport interface PaginationProps {\n  currentPage: number;\n  totalPages: number;\n  basePath?: string;\n}\n\nexport interface ItemListProps {\n  posts: ContentItem[];\n  currentPage: number;\n  totalPages: number;\n  heading?: string;\n  description?: string;\n  basePath?: string;\n  disablePagination?: boolean;\n  configuration?: ContentConfiguration;\n}\n\n// Alias for backward compatibility\nexport type PostListProps = ItemListProps;\n\nexport interface TableOfContentsProps {\n  pageBlock: PageBlock | null;\n  recordMap: ExtendedRecordMap;\n}\n",
      "type": "registry:lib",
      "target": "components/notion/types.ts"
    },
    {
      "path": "components/notion/README.md",
      "content": "# Notion CMS\n\nContent management powered by Notion.\n\n## Quick Start\n\n1. **Create `notion.config.ts`** in project root (see `examples/notion.config.ts`)\n\n2. **Set environment variables:**\n```bash\nNOTION_API_KEY=your_token\nNOTION_BLOG_DATABASE_ID=your_database_id\n```\n\n3. **Create page route** at `app/blog/[[...slug]]/page.tsx` (see `examples/blog-page.tsx`)\n\n4. **Create layout** at `app/blog/layout.tsx` (see `examples/blog-layout.tsx`)\n\n## Notion Database Properties\n\n- `Name` (Title) - Post title\n- `Slug` (Text) - URL slug\n- `Description` (Text) - Description\n- `Date` (Date) - Publish date\n- `Published` (Status) - Use \"Done\" for published\n- `Tags` (Relation) - Optional\n- `Author` (Relation) - Optional\n\n## SEO Metadata\n\nExport `generateMetadata` for automatic SEO:\n\n```typescript\nconst { generateStaticParams, generateMetadata, Page } = createContentSource({\n  source,\n  client,\n  compatClient,\n  siteName: \"My Site\",\n  baseUrl: \"https://example.com\",\n  // Transform metadata with your own utility\n  transformMetadata: (meta) => ({\n    ...meta,\n    title: `${meta.title} | My Site`,\n  }),\n});\n\nexport { generateStaticParams, generateMetadata };\n```\n\n## Custom Components\n\nPass custom components to `createContentSource`:\n\n```typescript\ncreateContentSource({\n  source,\n  client,\n  compatClient,\n  ListComponent: MyCustomList,  // For list pages\n  PageComponent: MyCustomPage,  // For detail pages\n});\n```\n\nSee `examples/` folder for custom component examples.\n\n## Primitives\n\nFor full control, use functions directly:\n\n- `getPublishedPosts(client, databaseId)`\n- `getTags(client, tagDatabaseId)`\n- `getAuthors(client, authorDatabaseId)`\n- `getPage(compatClient, pageId, tags?)`\n- `getPageBySlug(client, databaseId, slug)`\n- `mapNotionPageToContentItem(page, tags, basePath, authors)`\n\nSee `examples/primitives-example.tsx` for full usage.\n\n## Examples\n\nAll examples in `components/notion/examples/`:\n\n| File | Description |\n|------|-------------|\n| `notion.config.ts` | Config file template |\n| `blog-page.tsx` | Default blog route |\n| `blog-layout.tsx` | Layout with container |\n| `changelog-list.tsx` | Timeline list component |\n| `changelog-page.tsx` | Simple detail page |\n| `news-list.tsx` | Card grid list |\n| `primitives-example.tsx` | Direct primitives usage |\n",
      "type": "registry:file",
      "target": "components/notion/README.md"
    },
    {
      "path": "components/notion/examples/notion.config.ts",
      "content": "/**\n * Example: Notion CMS Configuration\n *\n * Copy this file to your project root as `notion.config.ts`\n * and customize the sources for your needs.\n */\n\nimport { defineNotionConfig } from \"@/lib/notion/config\";\n\nconst config = defineNotionConfig({\n  apiKey: process.env.NOTION_API_KEY!,\n\n  // Optional: Shared author database for all sources\n  authorDatabaseId: process.env.NOTION_AUTHOR_DATABASE_ID,\n\n  sources: {\n    // Blog source - powers /blog routes\n    blog: {\n      databaseId: process.env.NOTION_BLOG_DATABASE_ID!,\n      tagDatabaseId: process.env.NOTION_TAG_DATABASE_ID,\n      basePath: \"/blog\",\n      postsPerPage: 6,\n    },\n\n    // Changelog source - powers /changelog routes\n    changelog: {\n      databaseId: process.env.NOTION_CHANGELOGS_DATABASE_ID!,\n      basePath: \"/changelog\",\n      postsPerPage: 10,\n    },\n\n    // News source - powers /news routes\n    news: {\n      databaseId: process.env.NOTION_NEWS_DATABASE_ID!,\n      basePath: \"/news\",\n      postsPerPage: 6,\n    },\n\n    // Updates source - powers /updates routes\n    updates: {\n      databaseId: process.env.NOTION_UPDATES_DATABASE_ID!,\n      basePath: \"/updates\",\n      postsPerPage: 10,\n    },\n  },\n});\n\nexport default config;\n",
      "type": "registry:file",
      "target": "components/notion/examples/notion.config.ts"
    },
    {
      "path": "components/notion/examples/blog-page.tsx",
      "content": "/**\n * Example: Blog Page Route\n *\n * Copy this to `app/blog/[[...slug]]/page.tsx` in your project.\n * Uses the default ContentList and ContentPage components.\n */\n\nimport notionConfig from \"@/notion.config\";\nimport { createNotionClient } from \"@/lib/notion/notion-client\";\nimport { createContentSource } from \"@/lib/notion/content-page\";\n// Optional: import your own metadata utility\n// import { createMetadata } from \"@/lib/metadata\";\n\nconst source = notionConfig.sources.blog;\nconst { client, compatClient } = createNotionClient(notionConfig.apiKey);\n\nconst { generateStaticParams, generateMetadata, Page } = createContentSource({\n  source,\n  client,\n  compatClient,\n  listHeading: \"Latest Posts\",\n  tagHeadingPrefix: \"Posts tagged with:\",\n  contentLabel: \"Post\",\n  authorDatabaseId: notionConfig.authorDatabaseId,\n  // Metadata options\n  siteName: \"My Site\",\n  baseUrl: \"https://example.com\",\n  // Optional: Transform metadata with your own utility\n  // transformMetadata: (meta) => createMetadata({\n  //   ...meta,\n  //   title: `${meta.title} | My Site`,\n  // }),\n  // Optional: TOC configuration for fixed headers\n  tocConfig: {\n    headerOffset: 80,\n    mobileTopClass: \"top-14\",\n  },\n});\n\nexport { generateStaticParams, generateMetadata };\nexport default Page;\n",
      "type": "registry:file",
      "target": "components/notion/examples/blog-page.tsx"
    },
    {
      "path": "components/notion/examples/blog-layout.tsx",
      "content": "/**\n * Example: Blog Layout\n *\n * Copy this to `app/blog/layout.tsx` in your project.\n * Controls the width and styling of the blog section.\n */\n\nimport type { ReactNode } from \"react\";\n\nexport default function Layout({ children }: { children: ReactNode }) {\n  return (\n    <div className=\"container max-w-5xl mx-auto px-4\">\n      {children}\n    </div>\n  );\n}\n",
      "type": "registry:file",
      "target": "components/notion/examples/blog-layout.tsx"
    },
    {
      "path": "components/notion/examples/changelog-list.tsx",
      "content": "/**\n * Example: Custom Changelog List Component\n *\n * This demonstrates how to create a completely custom list component\n * for a specific content type. This uses a timeline-style layout\n * different from the default blog list.\n */\n\nimport Link from \"next/link\";\nimport type { CustomListComponentProps } from \"@/components/notion/types\";\nimport { Pagination } from \"@/components/notion/pagination\";\n\nexport function ChangelogList({\n  items,\n  currentPage,\n  totalPages,\n  heading,\n  basePath,\n}: CustomListComponentProps) {\n  return (\n    <div className=\"py-8 lg:py-12\">\n      <header className=\"mb-12\">\n        <h1 className=\"text-4xl font-bold mb-2\">{heading}</h1>\n        <p className=\"text-muted-foreground\">\n          Track all the latest updates and improvements\n        </p>\n      </header>\n\n      {/* Timeline layout */}\n      <div className=\"relative\">\n        {/* Vertical line */}\n        <div className=\"absolute left-4 top-0 bottom-0 w-px bg-border\" />\n\n        <div className=\"space-y-8\">\n          {items.map((item) => (\n            <article key={item.id} className=\"relative pl-12\">\n              {/* Timeline dot */}\n              <div className=\"absolute left-2 top-2 w-5 h-5 rounded-full bg-primary border-4 border-background\" />\n\n              {/* Date badge */}\n              <time className=\"inline-block px-3 py-1 mb-3 text-xs font-medium bg-muted rounded-full\">\n                {new Date(item.data.date).toLocaleDateString(\"en-US\", {\n                  year: \"numeric\",\n                  month: \"short\",\n                  day: \"numeric\",\n                })}\n              </time>\n\n              {/* Content */}\n              <h2 className=\"text-xl font-semibold mb-2\">\n                <Link href={item.url} className=\"hover:underline\">\n                  {item.data.title}\n                </Link>\n              </h2>\n              <p className=\"text-muted-foreground mb-3\">{item.data.description}</p>\n\n              {/* Tags as badges */}\n              {item.data.tags.length > 0 && (\n                <div className=\"flex flex-wrap gap-2\">\n                  {item.data.tags.map((tag) => (\n                    <span\n                      key={tag}\n                      className=\"px-2 py-0.5 text-xs bg-secondary text-secondary-foreground rounded\"\n                    >\n                      {tag}\n                    </span>\n                  ))}\n                </div>\n              )}\n            </article>\n          ))}\n        </div>\n      </div>\n\n      {totalPages > 1 && (\n        <div className=\"mt-12 flex justify-center\">\n          <Pagination\n            currentPage={currentPage}\n            totalPages={totalPages}\n            basePath={basePath}\n          />\n        </div>\n      )}\n    </div>\n  );\n}\n",
      "type": "registry:component",
      "target": "components/notion/examples/changelog-list.tsx"
    },
    {
      "path": "components/notion/examples/changelog-page.tsx",
      "content": "/**\n * Example: Custom Changelog Page Component\n *\n * This demonstrates how to create a completely custom detail page\n * for changelog entries. It uses a simpler layout without TOC,\n * focused on version/release information.\n */\n\nimport { Renderer } from \"../renderer\";\nimport Link from \"next/link\";\nimport type { CustomPageComponentProps } from \"@/components/notion/types\";\nimport { ArrowLeft, Calendar, Tag } from \"lucide-react\";\n\nexport function ChangelogPage({\n  recordMap,\n  basePath = \"/changelog\",\n}: CustomPageComponentProps) {\n  const { title, description, tags = [], cover } = recordMap.pageInfo || {};\n\n  // Get the last edited time from the first block\n  const lastEditedTime =\n    recordMap.block[Object.keys(recordMap.block)[0]]?.value?.last_edited_time;\n\n  return (\n    <article className=\"py-8 lg:py-12\">\n      {/* Back link */}\n      <Link\n        href={basePath}\n        className=\"inline-flex items-center gap-2 text-sm text-muted-foreground hover:text-foreground mb-8\"\n      >\n        <ArrowLeft className=\"h-4 w-4\" />\n        Back to Changelog\n      </Link>\n\n      {/* Header */}\n      <header className=\"mb-8 pb-8 border-b border-border\">\n        {/* Version badge - you might extract this from title or a property */}\n        <div className=\"mb-4\">\n          <span className=\"inline-block px-3 py-1 text-sm font-semibold bg-primary text-primary-foreground rounded-full\">\n            Release\n          </span>\n        </div>\n\n        <h1 className=\"text-3xl md:text-4xl font-bold mb-4\">\n          {title || \"Untitled\"}\n        </h1>\n\n        {description && (\n          <p className=\"text-lg text-muted-foreground mb-4\">{description}</p>\n        )}\n\n        {/* Meta info */}\n        <div className=\"flex flex-wrap gap-4 text-sm text-muted-foreground\">\n          {lastEditedTime && (\n            <span className=\"inline-flex items-center gap-1.5\">\n              <Calendar className=\"h-4 w-4\" />\n              {new Date(lastEditedTime).toLocaleDateString(\"en-US\", {\n                year: \"numeric\",\n                month: \"long\",\n                day: \"numeric\",\n              })}\n            </span>\n          )}\n          {(tags as any[]).length > 0 && (\n            <span className=\"inline-flex items-center gap-1.5\">\n              <Tag className=\"h-4 w-4\" />\n              {(tags as any[]).map((t) => t.label).join(\", \")}\n            </span>\n          )}\n        </div>\n      </header>\n\n      {/* Content - no TOC, simpler layout */}\n      <div\n        className=\"prose prose-neutral dark:prose-invert max-w-none\n          prose-headings:font-semibold prose-headings:text-foreground\n          prose-h2:text-xl prose-h2:mt-8 prose-h2:mb-4\n          prose-h3:text-lg prose-h3:mt-6 prose-h3:mb-3\n          prose-p:text-muted-foreground\n          prose-li:text-muted-foreground\n          prose-a:text-primary hover:prose-a:text-primary/80\n          prose-code:text-sm prose-code:bg-muted prose-code:px-1.5 prose-code:py-0.5 prose-code:rounded\n          prose-pre:bg-card prose-pre:border prose-pre:border-border\"\n        style={{ \"--notion-max-width\": \"100%\" } as React.CSSProperties}\n      >\n        <Renderer\n          recordMap={recordMap}\n          fullPage={false}\n          darkMode={false}\n          showTableOfContents={false}\n        />\n      </div>\n\n      {/* Footer navigation */}\n      <footer className=\"mt-12 pt-8 border-t border-border\">\n        <Link\n          href={basePath}\n          className=\"inline-flex items-center gap-2 text-sm font-medium text-primary hover:underline\"\n        >\n          <ArrowLeft className=\"h-4 w-4\" />\n          View all changelog entries\n        </Link>\n      </footer>\n    </article>\n  );\n}\n",
      "type": "registry:component",
      "target": "components/notion/examples/changelog-page.tsx"
    },
    {
      "path": "components/notion/examples/changelog-route.tsx",
      "content": "/**\n * Example: Changelog Page Route with Custom Components\n *\n * Copy this to `app/changelog/[[...slug]]/page.tsx` in your project.\n * Uses custom ChangelogList (timeline) and ChangelogPage (simple) components.\n */\n\nimport notionConfig from \"@/notion.config\";\nimport { createNotionClient } from \"@/lib/notion/notion-client\";\nimport { createContentSource } from \"@/lib/notion/content-page\";\nimport { ChangelogList } from \"@/components/notion/examples/changelog-list\";\nimport { ChangelogPage } from \"@/components/notion/examples/changelog-page\";\n\nconst source = notionConfig.sources.changelog;\nconst { client, compatClient } = createNotionClient(notionConfig.apiKey);\n\nconst { generateStaticParams, Page } = createContentSource({\n  source,\n  client,\n  compatClient,\n  listHeading: \"Changelog\",\n  contentLabel: \"Entry\",\n  authorDatabaseId: notionConfig.authorDatabaseId,\n  // Custom components for different layout\n  ListComponent: ChangelogList,\n  PageComponent: ChangelogPage,\n});\n\nexport { generateStaticParams };\nexport default Page;\n",
      "type": "registry:file",
      "target": "components/notion/examples/changelog-route.tsx"
    },
    {
      "path": "components/notion/examples/news-list.tsx",
      "content": "import Link from \"next/link\";\nimport type { CustomListComponentProps } from \"@/components/notion/types\";\nimport { Pagination } from \"@/components/notion/pagination\";\n\nexport function NewsList({\n  items,\n  currentPage,\n  totalPages,\n  heading,\n  basePath,\n}: CustomListComponentProps) {\n  return (\n    <div className=\"py-8 lg:py-12\">\n      <header className=\"mb-12 text-center\">\n        <h1 className=\"text-4xl font-bold mb-2\">{heading}</h1>\n        <p className=\"text-muted-foreground\">\n          Stay informed with the latest news and announcements\n        </p>\n      </header>\n\n      {/* Card grid */}\n      <div className=\"grid gap-6 sm:grid-cols-2 lg:grid-cols-3\">\n        {items.map((item) => (\n          <article\n            key={item.id}\n            className=\"group rounded-lg border border-border bg-card overflow-hidden hover:shadow-lg transition-shadow\"\n          >\n            {/* Card image */}\n            <div className=\"aspect-video bg-muted relative overflow-hidden\">\n              {item.data.cover ? (\n                <img\n                  src={item.data.cover}\n                  alt={item.data.title}\n                  className=\"w-full h-full object-cover group-hover:scale-105 transition-transform duration-300\"\n                />\n              ) : (\n                <div className=\"w-full h-full flex items-center justify-center text-muted-foreground\">\n                  <span className=\"text-4xl\">üì∞</span>\n                </div>\n              )}\n              {/* Category badge */}\n              {item.data.tags[0] && (\n                <span className=\"absolute top-3 left-3 px-2 py-1 text-xs font-medium bg-primary text-primary-foreground rounded\">\n                  {item.data.tags[0]}\n                </span>\n              )}\n            </div>\n\n            {/* Card content */}\n            <div className=\"p-4\">\n              <time className=\"text-xs text-muted-foreground\">\n                {new Date(item.data.date).toLocaleDateString(\"en-US\", {\n                  year: \"numeric\",\n                  month: \"long\",\n                  day: \"numeric\",\n                })}\n              </time>\n              <h2 className=\"mt-2 text-lg font-semibold line-clamp-2\">\n                <Link href={item.url} className=\"hover:underline\">\n                  {item.data.title}\n                </Link>\n              </h2>\n              <p className=\"mt-2 text-sm text-muted-foreground line-clamp-3\">\n                {item.data.description}\n              </p>\n              {item.data.author && (\n                <p className=\"mt-3 text-xs text-muted-foreground\">\n                  By {item.data.author}\n                </p>\n              )}\n            </div>\n          </article>\n        ))}\n      </div>\n\n      {totalPages > 1 && (\n        <div className=\"mt-12 flex justify-center\">\n          <Pagination\n            currentPage={currentPage}\n            totalPages={totalPages}\n            basePath={basePath}\n          />\n        </div>\n      )}\n    </div>\n  );\n}\n",
      "type": "registry:component",
      "target": "components/notion/examples/news-list.tsx"
    },
    {
      "path": "components/notion/examples/news-route.tsx",
      "content": "/**\n * Example: News Page Route with Custom List Component\n *\n * Copy this to `app/news/[[...slug]]/page.tsx` in your project.\n * Uses custom NewsList (card grid) component for list, default ContentPage for detail.\n */\n\nimport notionConfig from \"@/notion.config\";\nimport { createNotionClient } from \"@/lib/notion/notion-client\";\nimport { createContentSource } from \"@/lib/notion/content-page\";\nimport { NewsList } from \"@/components/notion/examples/news-list\";\n\nconst source = notionConfig.sources.news;\nconst { client, compatClient } = createNotionClient(notionConfig.apiKey);\n\nconst { generateStaticParams, Page } = createContentSource({\n  source,\n  client,\n  compatClient,\n  listHeading: \"News\",\n  contentLabel: \"Article\",\n  authorDatabaseId: notionConfig.authorDatabaseId,\n  // Custom list component, uses default ContentPage for detail\n  ListComponent: NewsList,\n});\n\nexport { generateStaticParams };\nexport default Page;\n",
      "type": "registry:file",
      "target": "components/notion/examples/news-route.tsx"
    },
    {
      "path": "components/notion/examples/primitives-example.tsx",
      "content": "/**\n * Example: Using Primitives Directly (Full Control)\n *\n * This file shows how to build a completely custom page\n * without using createContentSource at all.\n *\n * Use this approach when you need:\n * - Custom routing logic\n * - Different data fetching patterns\n * - Complete control over the page structure\n *\n * Copy this pattern to your page.tsx file and customize.\n */\n\nimport { Client } from \"@notionhq/client\";\nimport { NotionCompatAPI } from \"notion-compat\";\nimport {\n  getPublishedPosts,\n  getTags,\n  getAuthors,\n  getPage,\n  getPageBySlug,\n} from \"@/lib/notion/notion\";\nimport { mapNotionPageToContentItem } from \"@/lib/notion/notion-mappers\";\nimport type { ContentItem, Tag, Author } from \"@/components/notion/types\";\n\n// Initialize clients\nconst client = new Client({ auth: process.env.NOTION_API_KEY });\nconst compatClient = new NotionCompatAPI(client);\n\n// Config\nconst DATABASE_ID = process.env.NOTION_BLOG_DATABASE_ID!;\nconst TAG_DATABASE_ID = process.env.NOTION_TAG_DATABASE_ID;\nconst AUTHOR_DATABASE_ID = process.env.NOTION_AUTHOR_DATABASE_ID;\nconst BASE_PATH = \"/my-custom-blog\";\n\n/**\n * Generate static paths for all posts\n */\nexport async function generateStaticParams() {\n  const response = await getPublishedPosts(client, DATABASE_ID);\n  const posts = response.results as any[];\n\n  return posts.map((post) => ({\n    slug: [post.properties.Slug?.rich_text?.[0]?.plain_text || post.id],\n  }));\n}\n\n/**\n * Custom page component with full control\n */\nexport default async function CustomBlogPage({\n  params,\n}: {\n  params: Promise<{ slug?: string[] }>;\n}) {\n  const { slug = [] } = await params;\n\n  // Fetch all data\n  const postsResponse = await getPublishedPosts(client, DATABASE_ID);\n  const posts = postsResponse.results as any[];\n\n  const tags: Tag[] = TAG_DATABASE_ID\n    ? await getTags(client, TAG_DATABASE_ID)\n    : [];\n\n  const authors: Author[] = AUTHOR_DATABASE_ID\n    ? await getAuthors(client, AUTHOR_DATABASE_ID)\n    : [];\n\n  // Map to content items\n  const items: ContentItem[] = posts\n    .map((post) => mapNotionPageToContentItem(post, tags, BASE_PATH, authors))\n    .filter((item): item is ContentItem => item !== null);\n\n  // List page (no slug)\n  if (slug.length === 0) {\n    return (\n      <div className=\"py-12\">\n        <h1 className=\"text-4xl font-bold mb-8\">My Custom Blog</h1>\n        <div className=\"space-y-6\">\n          {items.map((item) => (\n            <article key={item.id} className=\"border-b pb-6\">\n              <h2 className=\"text-2xl font-semibold\">\n                <a href={item.url} className=\"hover:underline\">\n                  {item.data.title}\n                </a>\n              </h2>\n              <p className=\"text-muted-foreground mt-2\">\n                {item.data.description}\n              </p>\n              <div className=\"text-sm text-muted-foreground mt-2\">\n                {item.data.author && <span>By {item.data.author} ‚Ä¢ </span>}\n                {new Date(item.data.date).toLocaleDateString()}\n              </div>\n            </article>\n          ))}\n        </div>\n      </div>\n    );\n  }\n\n  // Detail page\n  const postSlug = slug[0];\n  const post = await getPageBySlug(client, DATABASE_ID, postSlug);\n\n  if (!post) {\n    return <div>Post not found</div>;\n  }\n\n  const recordMap = await getPage(compatClient, post.id, tags);\n\n  // Render with your own layout - import Renderer from components/notion/renderer\n  // return <Renderer recordMap={recordMap} />;\n\n  return (\n    <div className=\"py-12\">\n      <h1 className=\"text-4xl font-bold mb-4\">\n        {recordMap.pageInfo?.title || \"Untitled\"}\n      </h1>\n      <p className=\"text-muted-foreground mb-8\">\n        {recordMap.pageInfo?.description}\n      </p>\n      {/* Add your custom rendering here */}\n      <p className=\"text-sm text-muted-foreground\">\n        Import and use the Renderer component to display Notion content\n      </p>\n    </div>\n  );\n}\n",
      "type": "registry:file",
      "target": "components/notion/examples/primitives-example.tsx"
    }
  ],
  "css": {
    "@import \"react-notion-x/src/styles.css\"": {},
    "@import \"prismjs/themes/prism-tomorrow.css\"": {}
  },
  "envVars": {
    "NOTION_API_KEY": ""
  },
  "type": "registry:block"
}